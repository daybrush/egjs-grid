{"version":3,"file":"grid.min.js","sources":["../src/consts.ts","../src/ContainerManager.ts","../src/utils.ts","../src/ItemRenderer.ts","../src/GridItem.ts","../src/Grid.ts","../src/grids/MasonryGrid.ts","../src/grids/lib/dijkstra.ts","../src/grids/JustifiedGrid.ts","../src/grids/FrameGrid.ts","../src/grids/lib/BoxModel.ts","../src/grids/PackingGrid.ts","../src/index.umd.ts"],"sourcesContent":["import { GridOptions } from \"./types\";\n\nexport const DEFAULT_GRID_OPTIONS: Required<GridOptions> = {\n  horizontal: false,\n  useTransform: false,\n  percentage: false,\n  isEqualSize: false,\n  isConstantSize: false,\n  gap: 0,\n  attributePrefix: \"data-grid-\",\n  resizeDebounce: 100,\n  maxResizeDebounce: 0,\n  autoResize: true,\n  defaultDirection: \"end\",\n  externalContainerManager: null,\n  externalItemRenderer: null,\n  renderOnPropertyChange: true,\n};\n\nexport enum PROPERTY_TYPE {\n  PROPERTY = 1,\n  RENDER_PROPERTY = 2,\n}\nexport enum MOUNT_STATE {\n  UNCHECKED = 1,\n  UNMOUNTED = 2,\n  MOUNTED = 3,\n}\nexport enum UPDATE_STATE {\n  NEED_UPDATE = 1,\n  WAIT_LOADING = 2,\n  UPDATED = 3,\n}\n\nexport const GRID_PROPERTY_TYPES = {\n  gap: PROPERTY_TYPE.RENDER_PROPERTY,\n  defaultDirection: PROPERTY_TYPE.PROPERTY,\n  renderOnPropertyChange: PROPERTY_TYPE.PROPERTY,\n};\n\nexport const GRID_METHODS = [\n  \"syncElements\",\n  \"updateItems\",\n  \"getItems\",\n  \"setItems\",\n  \"renderItems\",\n  \"getContainerInlineSize\",\n] as const;\n\nexport const GRID_EVENTS = [\n  \"renderComplete\",\n  \"contentError\",\n] as const;\n\nexport const RECT_NAMES = {\n  horizontal: {\n    inlinePos: \"top\",\n    contentPos: \"left\",\n    inlineSize: \"height\",\n    contentSize: \"width\",\n  },\n  vertical: {\n    inlinePos: \"left\",\n    contentPos: \"top\",\n    inlineSize: \"width\",\n    contentSize: \"height\",\n  },\n} as const;\n","import { DestroyOptions } from \".\";\nimport { DEFAULT_GRID_OPTIONS } from \"./consts\";\nimport { DOMRect } from \"./types\";\n\nexport interface ContainerManagerOptions {\n  horizontal?: boolean;\n}\n\nexport interface ContainerManagerStatus {\n  rect: DOMRect;\n}\n\nexport class ContainerManager {\n  protected options: Required<ContainerManagerOptions>;\n  protected rect: DOMRect;\n  protected orgCSSText: string;\n\n  constructor(protected container: HTMLElement, options: ContainerManagerOptions) {\n    this.options = {\n      horizontal: DEFAULT_GRID_OPTIONS.horizontal,\n      ...options,\n    };\n\n    this._init();\n  }\n  public resize() {\n    const container = this.container;\n\n    this.setRect({\n      width: container.offsetWidth,\n      height: container.offsetHeight,\n    });\n  }\n  public getRect() {\n    return this.rect;\n  }\n  public setRect(rect: DOMRect) {\n    this.rect = { ...rect };\n  }\n  public getInlineSize() {\n    return this.rect[this.options.horizontal ? \"height\" : \"width\"];\n  }\n  public getContentSize() {\n    return this.rect[this.options.horizontal ? \"width\" : \"height\"]!;\n  }\n  public getStatus() {\n    return {\n      rect: { ...this.rect },\n    };\n  }\n  public setStatus(status: ContainerManagerStatus) {\n    this.rect = { ...status.rect };\n\n    this.setContentSize(this.getContentSize());\n  }\n  public setContentSize(size: number) {\n    const sizeName = this.options.horizontal ? \"width\" : \"height\";\n    this.rect[sizeName] = size;\n    this.container.style[sizeName] = `${size}px`;\n  }\n  public destroy(options: DestroyOptions = {}) {\n    if (!options.preserveUI) {\n      this.container.style.cssText = this.orgCSSText;\n    }\n  }\n  private _init() {\n    const container = this.container;\n    const style = window.getComputedStyle(container);\n\n    this.orgCSSText = container.style.cssText;\n\n    if (style.position === \"static\") {\n      container.style.position = \"relative\";\n    }\n  }\n}\n","import Grid from \"./Grid\";\nimport { GRID_METHODS, GRID_PROPERTY_TYPES, PROPERTY_TYPE } from \"./consts\";\n\nexport function getKeys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\nexport function isNumber(val: any): val is number {\n  return typeof val === \"number\";\n}\n\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\nexport function getDataAttributes(element: HTMLElement, attributePrefix: string) {\n  const dataAttributes: Record<string, string> = {};\n  const attributes = element.attributes;\n  const length = attributes.length;\n\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    const { name, value } = attribute;\n    if (name.indexOf(attributePrefix) === -1) {\n      continue;\n    }\n    dataAttributes[camelize(name.replace(attributePrefix, \"\"))] = value;\n  }\n\n  return dataAttributes;\n}\n\n/* Class Decorator */\nexport function GetterSetter(component: {\n  prototype: Grid<any>,\n  propertyTypes: typeof GRID_PROPERTY_TYPES,\n}) {\n  const {\n    prototype,\n    propertyTypes,\n  } = component;\n  for (const name in propertyTypes) {\n    const shouldRender = propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY;\n    const attributes: Record<string, any> = {\n      enumerable: true,\n      configurable: true,\n      get(this: Grid) {\n        return this.options[name];\n      },\n      set(this: Grid, value: any) {\n        const options = this.options;\n        const prevValue = options[name];\n\n        if (prevValue === value) {\n          return;\n        }\n        options[name] = value;\n\n        if (shouldRender && options.renderOnPropertyChange) {\n          this.scheduleRender();\n        }\n      },\n    };\n    Object.defineProperty(prototype, name, attributes);\n  }\n}\n\nexport function withMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n\nexport function range(length: number): number[] {\n  const arr: number[] = [];\n  for (let i = 0; i < length; ++i) {\n    arr.push(i);\n  }\n  return arr;\n}\n\nexport function getRangeCost(value: number, range: number[]) {\n  return Math.max(value - range[1], range[0] - value, 0) + 1;\n}\n\n/**\n * Decorator that makes the method of grid available in the framework.\n * @ko 프레임워크에서 그리드의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Grid\n * @private\n * @example\n * ```js\n * import { withGridMethods } from \"@egjs/grid\";\n *\n * class Grid extends React.Component<Partial<GridProps & GridOptions>> {\n *   &#64;withGridMethods\n *   private grid: NativeGrid;\n * }\n * ```\n */\nexport const withGridMethods = withMethods(GRID_METHODS);\n","import { DEFAULT_GRID_OPTIONS, MOUNT_STATE, RECT_NAMES, UPDATE_STATE } from \"./consts\";\nimport { GridItem } from \"./GridItem\";\nimport { DOMRect } from \"./types\";\nimport { getDataAttributes, getKeys } from \"./utils\";\n\nexport interface ItemRendererOptions {\n  attributePrefix?: string;\n  useTransform?: boolean;\n  horizontal?: boolean;\n  percentage?: Array<\"position\" | \"size\"> | boolean;\n  isEqualSize?: boolean;\n  isConstantSize?: boolean;\n}\nexport interface ItemRendererStatus {\n  initialRect: Required<DOMRect> | null;\n}\n\nexport class ItemRenderer {\n  protected options: Required<ItemRendererOptions>;\n  protected containerRect: DOMRect;\n  protected initialRect: Required<DOMRect> | null = null;\n  protected sizePercetage = false;\n  protected posPercetage = false;\n\n  constructor(options: ItemRendererOptions) {\n    this.options = {\n      attributePrefix: DEFAULT_GRID_OPTIONS.attributePrefix,\n      useTransform: DEFAULT_GRID_OPTIONS.useTransform,\n      horizontal: DEFAULT_GRID_OPTIONS.horizontal,\n      percentage: DEFAULT_GRID_OPTIONS.percentage,\n      isEqualSize: DEFAULT_GRID_OPTIONS.isEqualSize,\n      isConstantSize: DEFAULT_GRID_OPTIONS.isConstantSize,\n      ...options,\n    };\n    this._init();\n  }\n  public resize() {\n    this.initialRect = null;\n  }\n  public renderItems(items: GridItem[]) {\n    items.forEach((item) => {\n      this._renderItem(item);\n    });\n  }\n  public getInlineSize() {\n    return this.containerRect[this.options.horizontal ? \"height\" : \"width\"]!;\n  }\n  public setContainerRect(rect: DOMRect) {\n    this.containerRect = rect;\n  }\n  public updateItems(items: GridItem[]) {\n    items.forEach((item) => {\n      this._updateItem(item);\n    });\n  }\n  public getStatus(): ItemRendererStatus {\n    return {\n      initialRect: this.initialRect,\n    };\n  }\n  public setStatus(status: ItemRendererStatus) {\n    this.initialRect = status.initialRect;\n  }\n  private _init() {\n    const { percentage } = this.options;\n\n    let sizePercentage = false;\n    let posPercentage = false;\n\n    if (percentage === true) {\n      sizePercentage = true;\n      posPercentage = true;\n    } else if (percentage) {\n      if (percentage.indexOf(\"position\") > -1) {\n        posPercentage = true;\n      }\n      if (percentage.indexOf(\"size\") > -1) {\n        sizePercentage = true;\n      }\n    }\n\n    this.posPercetage = posPercentage;\n    this.sizePercetage = sizePercentage;\n  }\n  private _updateItem(item: GridItem) {\n    const { isEqualSize, isConstantSize } = this.options;\n    const initialRect = this.initialRect;\n    const { orgRect, element } = item;\n    const hasOrgRect = orgRect && orgRect.width && orgRect.height;\n    let rect: Required<DOMRect>;\n\n    if (isEqualSize && initialRect) {\n      rect = initialRect;\n    } else if (isConstantSize && hasOrgRect) {\n      rect = orgRect;\n    } else if (!element) {\n      return;\n    } else {\n      rect = {\n        left: element.offsetLeft,\n        top: element.offsetTop,\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n      };\n    }\n    if (!hasOrgRect) {\n      item.orgRect = { ...rect };\n    }\n    item.rect = { ...rect };\n\n    if (item.element) {\n      item.mountState = MOUNT_STATE.MOUNTED;\n    }\n    if (item.updateState === UPDATE_STATE.NEED_UPDATE) {\n      item.updateState = UPDATE_STATE.UPDATED;\n    }\n    item.attributes = element ? getDataAttributes(element, this.options.attributePrefix) : {};\n    this.initialRect = { ...rect };\n\n    return rect;\n  }\n  private _renderItem(item: GridItem) {\n    const element = item.element;\n    const cssRect = item.cssRect;\n\n    if (!element || !cssRect) {\n      return;\n    }\n\n    const {\n      horizontal,\n      useTransform,\n    } = this.options;\n    const posPercentage = this.posPercetage;\n    const sizePercentage = this.sizePercetage;\n    const cssTexts: string[] = [\"position: absolute;\"];\n    const {\n      inlineSize: sizeName,\n      inlinePos: posName,\n    } = RECT_NAMES[horizontal ? \"horizontal\": \"vertical\"];\n    const inlineSize = this.getInlineSize();\n    let keys = getKeys(cssRect);\n\n    if (useTransform) {\n      keys = keys.filter((key) => key !== \"top\" && key !== \"left\");\n\n      cssTexts.push(`transform: `\n        + `translate(${cssRect.left || 0}px, ${cssRect.top || 0}px);`\n      );\n    }\n    cssTexts.push(...keys.map((name) => {\n      const value = cssRect[name]!;\n\n      if (\n        (name === sizeName && sizePercentage) ||\n        (name === posName && posPercentage)\n      ) {\n        return `${name}: ${(value / inlineSize) * 100}%;`;\n      }\n      return `${name}: ${value}px;`;\n    }));\n\n    element.style.cssText += cssTexts.join(\"\");\n  }\n}\n","import { DOMRect, GridRect } from \"./types\";\nimport { MOUNT_STATE, RECT_NAMES, UPDATE_STATE } from \"./consts\";\n\n/**\n * @typedef\n * @memberof Grid.GridItem\n * @property - The item key. <ko>아이템 키.</ko>\n * @property - The element for the item. <ko>아이템에 있는 엘리먼트.</ko>\n * @property - State of whether the element has been added to the container. <ko>element가 container에 추가되었는지 상태.</ko>\n * @property - The update state of the element's rect. <ko>element의 rect의 업데이트 상태.</ko>\n * @property - Attributes set as `data-grid-` of element. <ko>element의 `data-grid-`으로 설정된 속성들.</ko>\n * @property - cssText of the first style when an element is added to the container. <ko>element가 container에 추가됐을 때 처음 style의 cssText.</ko>\n * @property - The element's rect before first rendering. <ko>처음 렌더링 하기 전 엘리먼트의 rect.</ko>\n * @property - The updated element's rect before rendering. <ko>렌더링 하기 전 업데이트 된 엘리먼트의 rect.</ko>\n * @property - The CSS rect of the item to be rendered by being applied to the Grid. <ko>Grid에 적용되어 렌더링을 하기 위한 item의 CSS rect</ko>\n * @property - Additional data of the item. <ko>item의 추가적인 데이터들.</ko>\n */\nexport interface GridItemStatus {\n  key?: string;\n  element?: HTMLElement | null;\n  mountState?: MOUNT_STATE;\n  updateState?: UPDATE_STATE;\n  attributes?: Record<string, string>;\n  orgCSSText?: string;\n  orgRect?: Required<DOMRect>;\n  rect?: Required<DOMRect>;\n  cssRect?: DOMRect;\n  data?: Record<string, string>;\n}\n\n\n/**\n * @memberof Grid\n * @implements Grid.GridItem.GridItemStatus\n */\nclass GridItem {\n  /**\n   * @constructor\n   * @param horizontal - Direction of the scroll movement. (true: horizontal, false: vertical) <ko>스크롤 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param itemStatus - Default status object of GridItem module. <ko>GridItem 모듈의 기본 status 객체.</ko>\n   */\n  constructor(\n    protected horizontal: boolean,\n    itemStatus: Partial<GridItemStatus> = {},\n  ) {\n    const element = itemStatus.element;\n    const status: Required<GridItemStatus> = {\n      key: \"\",\n      orgRect: { left: 0, top: 0, width: 0, height: 0 },\n      rect: { left: 0, top: 0, width: 0, height: 0 },\n      cssRect: {},\n      attributes: {},\n      data: {},\n      mountState: MOUNT_STATE.UNCHECKED,\n      updateState: UPDATE_STATE.NEED_UPDATE,\n      element: element || null,\n      orgCSSText: element?.style.cssText ?? \"\",\n      ...itemStatus,\n    };\n\n    for (const name in status) {\n      this[name] = status[name];\n    }\n  }\n  /**\n   * The size in inline direction before first rendering. \"width\" if horizontal is false, \"height\" otherwise.\n   * @ko 첫 렌더링 되기 전의 inline 방향의 사이즈. horizontal이 false면 \"width\", 아니면 \"height\".\n   * @member Grid.GridItem#orgInlineSize\n   */\n  public get orgInlineSize() {\n    const orgRect = this.orgRect;\n\n    return this.horizontal ? orgRect.height : orgRect.width;\n  }\n  /**\n   * The size in content direction before first rendering. \"height\" if horizontal is false, \"width\" otherwise.\n   * @ko 첫 렌더링 되기 전의 content 방향의 사이즈. horizontal이 false면 \"height\", 아니면 \"width\".\n   * @member Grid.GridItem#orgContentSize\n   */\n  public get orgContentSize() {\n    const orgRect = this.orgRect;\n\n    return this.horizontal ? orgRect.width : orgRect.height;\n  }\n  /**\n   * The size in inline direction. \"width\" if horizontal is false, \"height\" otherwise.\n   * @ko inline 방향의 사이즈. horizontal이 false면 \"width\", 아니면 \"height\".\n   * @member Grid.GridItem#inlineSize\n   */\n  public get inlineSize() {\n    const rect = this.rect;\n\n    return this.horizontal ? rect.height : rect.width;\n  }\n  /**\n   * The size in content direction. \"height\" if horizontal is false, \"width\" otherwise.\n   * @ko content 방향의 사이즈. horizontal이 false면 \"height\", 아니면 \"width\".\n   * @member Grid.GridItem#contentSize\n   */\n  public get contentSize() {\n    const rect = this.rect;\n\n    return this.horizontal ? rect.width : rect.height;\n  }\n  /**\n   * The CSS size in inline direction applied to the Grid. \"width\" if horizontal is false, \"height\" otherwise.\n   * @ko Grid에 적용된 inline 방향의 CSS 사이즈. horizontal이 false면 \"width\", 아니면 \"height\".\n   * @member Grid.GridItem#cssInlineSize\n   */\n  public get cssInlineSize() {\n    const cssRect = this.cssRect;\n\n    return this.horizontal ? cssRect.height! : cssRect.width!;\n  }\n  /**\n   * The CSS size in content direction applied to the Grid. \"height\" if horizontal is false, \"width\" otherwise.\n   * @ko Grid에 적용된 content 방향의 CSS 사이즈. horizontal이 false면 \"height\", 아니면 \"width\".\n   * @member Grid.GridItem#cssContentSize\n   */\n  public get cssContentSize() {\n    const cssRect = this.cssRect;\n\n    return this.horizontal ? cssRect.width! : cssRect.height!;\n  }\n  /**\n   * The CSS pos in inline direction applied to the Grid. \"left\" if horizontal is false, \"top\" otherwise.\n   * @ko Grid에 적용된 inline 방향의 CSS 포지션. horizontal이 false면 \"left\", 아니면 \"top\".\n   * @member Grid.GridItem#cssInlinePos\n   */\n  public get cssInlinePos() {\n    const cssRect = this.cssRect;\n\n    return this.horizontal ? cssRect.top! : cssRect.left!;\n  }\n  /**\n   * The CSS pos in content direction applied to the Grid. \"top\" if horizontal is false, \"left\" otherwise.\n   * @ko Grid에 적용된 content 방향의 CSS 포지션. horizontal이 false면 \"top\", 아니면 \"left\".\n   * @member Grid.GridItem#cssContentPos\n   */\n  public get cssContentPos() {\n    const cssRect = this.cssRect;\n\n    return this.horizontal ? cssRect.left! : cssRect.top!;\n  }\n  public set cssInlinePos(inlinePos: number) {\n    const cssRect = this.cssRect;\n\n    cssRect[this.horizontal ? \"top\" : \"left\"] = inlinePos;\n  }\n  public set cssContentPos(contentPos: number) {\n    const cssRect = this.cssRect;\n\n    cssRect[this.horizontal ? \"left\" : \"top\"] = contentPos;\n  }\n  public set cssInlineSize(inlineSize: number) {\n    const cssRect = this.cssRect;\n\n    cssRect[this.horizontal ? \"height\" : \"width\"] = inlineSize;\n  }\n  public set cssContentSize(contentSize: number) {\n    const cssRect = this.cssRect;\n\n    cssRect[this.horizontal ? \"width\" : \"height\"] = contentSize;\n  }\n  /**\n   * Set CSS Rect through GridRect.\n   * @ko GridRect을 통해 CSS Rect를 설정한다.\n   * @param - The style for setting CSS rect. <ko>CSS rect를 설정하기 위한 스타일.</ko>\n   */\n  public setCSSGridRect(gridRect: GridRect) {\n    const names = RECT_NAMES[this.horizontal ? \"horizontal\" : \"vertical\"];\n\n    const rect: DOMRect = {};\n\n    for (const name in gridRect) {\n      rect[names[name]] = gridRect[name];\n    }\n    this.cssRect = rect;\n  }\n  /**\n   * Returns the status of the item.\n   * @ko 아이템의 상태를 반환한다.\n   */\n  public getStatus(): GridItemStatus {\n    return {\n      mountState: this.mountState,\n      updateState: this.updateState,\n      attributes: this.attributes,\n      orgCSSText: this.orgCSSText,\n      element: null,\n      key: this.key,\n      orgRect: this.orgRect,\n      rect: this.rect,\n      cssRect: this.cssRect,\n      data: this.data,\n    };\n  }\n}\n\ninterface GridItem extends Required<GridItemStatus> {\n}\nexport { GridItem };\n","/* eslint-disable @typescript-eslint/indent */\nimport Component from \"@egjs/component\";\nimport { DEFAULT_GRID_OPTIONS, GRID_PROPERTY_TYPES, MOUNT_STATE, UPDATE_STATE } from \"./consts\";\nimport { ContainerManager } from \"./ContainerManager\";\nimport {\n  DestroyOptions, GridEvents, GridOptions,\n  GridOutlines, GridStatus, Properties, RenderOptions,\n  OnRenderComplete,\n} from \"./types\";\nimport ImReady from \"@egjs/imready\";\nimport { ItemRenderer } from \"./ItemRenderer\";\nimport { GetterSetter, isNumber, isString } from \"./utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { GridItem } from \"./GridItem\";\n\n/**\n * @extends eg.Component\n */\n@GetterSetter\nabstract class Grid<\n  Options extends GridOptions = GridOptions\n  > extends Component<GridEvents> {\n  public static defaultOptions: Required<GridOptions> = DEFAULT_GRID_OPTIONS;\n  public static propertyTypes = GRID_PROPERTY_TYPES;\n  public options: Required<Options>;\n  protected containerElement: HTMLElement;\n  protected containerManager: ContainerManager;\n  protected itemRenderer!: ItemRenderer;\n  protected items: GridItem[] = [];\n  protected outlines: GridOutlines = {\n    start: [],\n    end: [],\n  };\n  private _renderTimer = 0;\n  private _resizeTimer = 0;\n  private _maxResizeDebounceTimer = 0;\n  private _im: ImReady;\n\n  /**\n  * Apply the CSS rect of items to fit the Grid and calculate the outline.\n  * @ko  Grid에 맞게 아이템들의 CSS rect를 적용하고 outline을 계산한다.\n  * @abstract\n  * @method Grid#applyGrid\n  * @param {\"start\" | \"end\"} direcion - The direction to apply the Grid. (\"end\": start to end, \"start\": end to start) <ko>Grid를 적용할 방향. (\"end\": 시작에서 끝 방향, \"start\": 끝에서 시작 방향)</ko>\n  * @param {number[]} outline - The start outline to apply the Grid. <ko>Grid를 적용할 시작 outline.</ko>\n  */\n  public abstract applyGrid(items: GridItem[], direction: \"start\" | \"end\", outline: number[]): GridOutlines;\n\n  /**\n   * @param - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n   * @param - The option object of the Grid module <ko>Grid 모듈의 옵션 객체</ko>\n   */\n  constructor(containerElement: HTMLElement | string, options: Partial<Options> = {}) {\n    super();\n\n    this.options = {\n      ...((this.constructor as typeof Grid)\n        .defaultOptions as Required<Options>),\n      ...options,\n    };\n\n    this.containerElement = isString(containerElement)\n      ? document.querySelector<HTMLElement>(containerElement)!\n      : containerElement;\n\n    const {\n      isEqualSize,\n      isConstantSize,\n      useTransform,\n      horizontal,\n      percentage,\n    } = this.options;\n\n    // TODO: 테스트용 설정\n    this.containerManager = new ContainerManager(this.containerElement, {\n      horizontal,\n    });\n    this.itemRenderer = new ItemRenderer({\n      useTransform,\n      isEqualSize,\n      isConstantSize,\n      percentage,\n    });\n\n    this._init();\n  }\n  /**\n   * Return items.\n   * @ko 아이템들을 반환한다.\n   */\n  public getItems(): GridItem[] {\n    return this.items;\n  }\n  /**\n   * Returns the children of the container element.\n   * @ko 컨테이너 엘리먼트의 children을 반환한다.\n   */\n  public getChildren(): HTMLElement[] {\n    return [].slice.call(this.containerElement.children);\n  }\n  /**\n   * Set items.\n   * @ko 아이템들을 설정한다.\n   * @param items - The items to set. <ko>설정할 아이템들</ko>\n   */\n  public setItems(items: GridItem[]): this {\n    this.items = items;\n    return this;\n  }\n  /**\n   * Gets the container's inline size. (\"width\" if horizontal is false, otherwise \"height\")\n   * @ko container의 inline 사이즈를 가져온다. (horizontal이 false면 \"width\", 아니면 \"height\")\n   */\n  public getContainerInlineSize(): number {\n    return this.containerManager.getInlineSize()!;\n  }\n  /**\n   * Returns the outlines of the start and end of the Grid.\n   * @ko Grid의 처음과 끝의 outline을 반환한다.\n   */\n  public getOutlines(): GridOutlines {\n    return this.outlines;\n  }\n  /**\n   * Set outlines.\n   * @ko 아웃라인을 설정한다.\n   * @param items - The outlines to set. <ko>설정할 아웃라인.</ko>\n   */\n  public setOutlines(outlines: GridOutlines) {\n    this.outlines = outlines;\n    return this;\n  }\n  /**\n   * When elements change, it synchronizes and renders items.\n   * @ko elements가 바뀐 경우 동기화를 하고 렌더링을 한다.\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  public syncElements(options: RenderOptions = {}) {\n    const items = this.items;\n    const horizontal = this.options.horizontal;\n    const elements: HTMLElement[] = this.getChildren();\n    const { added, maintained, changed, removed } = diff(this.items.map((item) => item.element!), elements);\n\n    const nextItems: GridItem[] = [];\n\n    maintained.forEach(([beforeIndex, afterIndex]) => {\n      nextItems[afterIndex] = items[beforeIndex];\n    });\n    added.forEach((index) => {\n      nextItems[index] = new GridItem(horizontal!, {\n        element: elements[index],\n      });\n    });\n\n    this.setItems(nextItems);\n\n    if (added.length || removed.length || changed.length) {\n      this.renderItems(options);\n    }\n    return this;\n  }\n  /**\n   * Update the size of the items and render them.\n   * @ko 아이템들의 사이즈를 업데이트하고 렌더링을 한다.\n   * @param - Items to be updated. <ko>업데이트할 아이템들.</ko>\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  public updateItems(items: GridItem[] = this.items, options: RenderOptions = {}) {\n    items.forEach((item) => {\n      item.updateState = UPDATE_STATE.NEED_UPDATE;\n    });\n    this.checkReady(options);\n    return this;\n  }\n  /**\n   * Rearrange items to fit the grid and render them.\n   * @ko grid에 맞게 아이템을 재배치하고 렌더링을 한다.\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  public renderItems(options: RenderOptions = {}) {\n    this._clearRenderTimer();\n\n    if (!this.getItems().length && this.getChildren().length) {\n      this.syncElements(options);\n    } else if (options.useResize) {\n      // Resize container and Update all items\n      this._resizeContainer();\n      this.updateItems(this.items, options);\n    } else {\n      // Update only items that need to be updated.\n      this.checkReady(options);\n    }\n    return this;\n  }\n  /**\n   * Returns current status such as item's position, size. The returned status can be restored with the setStatus() method.\n   * @ko 아이템의 위치, 사이즈 등 현재 상태를 반환한다. 반환한 상태는 setStatus() 메서드로 복원할 수 있다.\n   */\n  public getStatus(): GridStatus {\n    return {\n      outlines: this.outlines,\n      items: this.items.map((item) => item.getStatus()),\n      containerManager: this.containerManager.getStatus(),\n      itemRenderer: this.itemRenderer.getStatus(),\n    };\n  }\n  /**\n   * Set status of the Grid module with the status returned through a call to the getStatus() method.\n   * @ko getStatus() 메서드에 대한 호출을 통해 반환된 상태로 Grid 모듈의 상태를 설정한다.\n   */\n  public setStatus(status: GridStatus) {\n    const horizontal = this.options.horizontal;\n    const containerManager = this.containerManager;\n    const prevInlineSize = containerManager.getInlineSize();\n    const children = this.getChildren();\n\n    this.itemRenderer.setStatus(status.itemRenderer);\n    containerManager.setStatus(status.containerManager);\n    this.outlines = status.outlines;\n    this.items = status.items.map((item, i) => new GridItem(horizontal!, {\n      ...item,\n      element: children[i],\n    }));\n\n    this.itemRenderer.renderItems(this.items);\n\n    if (prevInlineSize !== containerManager.getInlineSize()) {\n      this.renderItems({\n        useResize: true,\n      });\n    } else {\n      window.setTimeout(() => {\n        this._renderComplete({\n          mounted: this.items,\n          updated: [],\n          isResize: false,\n        });\n      });\n    }\n    return this;\n  }\n  /**\n   * Releases the instnace and events and returns the CSS of the container and elements.\n   * @ko 인스턴스와 이벤트를 해제하고 컨테이너와 엘리먼트들의 CSS를 되돌린다.\n   * @param Options for destroy. <ko>destory()를 위한 옵션</ko>\n   */\n  public destroy(options: DestroyOptions = {}) {\n    this.containerManager.destroy(options);\n\n    if (!options.preserveUI) {\n      this.items.forEach(({ element, orgCSSText }) => {\n        if (element) {\n          element.style.cssText = orgCSSText;\n        }\n      });\n    }\n    window.removeEventListener(\"resize\", this._scheduleResize);\n    this._im?.destroy();\n  }\n  protected checkReady(options: RenderOptions = {}) {\n    // Grid: renderItems => checkItems => _renderItems\n    const items = this.items;\n    const updated = items.filter((item) => item.element && item.updateState !== UPDATE_STATE.UPDATED);\n    const mounted: GridItem[] = updated.filter((item) => item.mountState !== MOUNT_STATE.MOUNTED);\n    const moreUpdated: GridItem[] = [];\n\n    this._im?.destroy();\n    this._im = new ImReady({\n      prefix: this.options.attributePrefix,\n    }).on(\"preReadyElement\", (e) => {\n      if (e.hasLoading) {\n        updated[e.index].updateState = UPDATE_STATE.WAIT_LOADING;\n      }\n    }).on(\"preReady\", () => {\n      this.itemRenderer.updateItems(updated);\n      this._renderItems(mounted, updated, options);\n    }).on(\"readyElement\", (e) => {\n      const item = updated[e.index];\n      if (e.hasLoading) {\n        item.updateState = UPDATE_STATE.NEED_UPDATE;\n\n        if (e.isPreReadyOver) {\n          this.itemRenderer.updateItems([item]);\n          this._renderItems([], [item], options);\n        }\n      }\n    }).on(\"error\", (e) => {\n      const item = items[e.index];\n      /**\n       * This event is fired when an error occurs in the content.\n       * @ko 콘텐츠 로드에 에러가 날 때 발생하는 이벤트.\n       * @event Grid#contentError\n       * @param {Grid.OnContentError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       * @param {HTMLElement} [e.element] - The item's element.<ko>아이템의 엘리먼트.</ko>\n       * @param {HTMLElement} [e.target] - The content element with error.<ko>에러난 발생한 콘텐츠 엘리먼트.</ko>\n       * @param {Grid.GridItem} [e.item] - The item with error content.<ko>에러난 콘텐츠를 가지고 있는 아이템</ko>\n       * @param {function} [e.update] - If you have fixed the error and want to recheck it, call update(). If you remove an element, call the syncElements() method.<ko>에러를 해결했고 재검사하고 싶으면 update()를 호출해라. 만약 엘리먼트를 삭제한 경우 syncElements() 메서드를 호출해라.</ko>\n       * @example\ngrid.on(\"contentError\", e => {\n  e.update();\n});\n      */\n      this.trigger(\"contentError\", {\n        element: e.element,\n        target: e.target,\n        item,\n        update: () => {\n          moreUpdated.push(item);\n        },\n      });\n    }).on(\"ready\", () => {\n      if (moreUpdated.length) {\n        this.updateItems(moreUpdated);\n      }\n    }).check(updated.map((item) => item.element!));\n  }\n\n  protected scheduleRender() {\n    this._clearRenderTimer();\n    this._renderTimer = window.setTimeout(() => {\n      this.renderItems();\n    });\n  }\n  private _fit() {\n    const outlines = this.outlines;\n    const startOutline = outlines.start;\n    const endOutline = outlines.end;\n    const outlineOffset = startOutline.length ? Math.min(...startOutline) : 0;\n\n    outlines.start = startOutline.map((point) => point - outlineOffset);\n    outlines.end = endOutline.map((point) => point - outlineOffset);\n\n    this.items.forEach((item) => {\n      const contentPos = item.cssContentPos;\n\n      if (!isNumber(contentPos)) {\n        return;\n      }\n      item.cssContentPos = contentPos - outlineOffset;\n    });\n  }\n  private _renderItems(mounted: GridItem[], updated: GridItem[], options: RenderOptions) {\n    const prevOutlines = this.outlines;\n    const direction = options.direction || this.options.defaultDirection!;\n    const prevOutline = options.outline || prevOutlines[direction === \"end\" ? \"start\" : \"end\"];\n    const items = this.items;\n    let nextOutlines = {\n      start: [...prevOutline],\n      end: [...prevOutline],\n    };\n    if (items.length) {\n      nextOutlines = this.applyGrid(this.items, direction, prevOutline);\n    }\n    this.setOutlines(nextOutlines);\n    this._fit();\n    this.itemRenderer.renderItems(this.items);\n    this._refreshContainerContentSize();\n    this._renderComplete({\n      mounted,\n      updated,\n      isResize: !!options.useResize,\n    });\n  }\n  private _renderComplete(e: OnRenderComplete) {\n    /**\n     * This event is fired when the Grid has completed rendering.\n     * @ko Grid가 렌더링이 완료됐을 때  발생하는 이벤트이다.\n     * @event Grid#renderComplete\n     * @param {Grid.OnRenderComplete} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @param {function} [e.mounted] - The items rendered for the first time <ko>처음 렌더링한 아이템들</ko>\n     * @param {function} [e.updated] - The items updated in size.<ko>사이즈 업데이트한 아이템들.</ko>\n     * @param {function} [e.useResize] - Whether rendering was done using the resize event or the useResize option. <ko>resize 이벤트 또는 useResize 옵션을 사용하여 렌더링를 했는지 여부.</ko>\n     * @example\ngrid.on(\"renderComplete\", e => {\nconsole.log(e.mounted, e.updated, e.useResize);\n});\n      */\n    this.trigger(\"renderComplete\", e);\n  }\n  private _clearRenderTimer() {\n    clearTimeout(this._renderTimer);\n    this._renderTimer = 0;\n  }\n  private _refreshContainerContentSize() {\n    const {\n      start: startOutline,\n      end: endOutline,\n    }  = this.outlines;\n    const gap = this.options.gap!;\n\n    const endPoint = endOutline.length ? Math.max(...endOutline): 0;\n    const startPoint = startOutline.length ? Math.max(...startOutline) : 0;\n    const contentSize = Math.max(startPoint, endPoint - gap);\n\n    this.containerManager.setContentSize(contentSize);\n  }\n  private _resizeContainer() {\n    this.containerManager.resize();\n    this.itemRenderer.setContainerRect(this.containerManager.getRect());\n  }\n  private _onResize = () => {\n    clearTimeout(this._resizeTimer);\n    clearTimeout(this._maxResizeDebounceTimer);\n\n    this._maxResizeDebounceTimer = 0;\n    this._resizeTimer = 0;\n    this.renderItems({\n      useResize: true,\n    });\n  }\n  private _scheduleResize = () => {\n    const {\n      resizeDebounce,\n      maxResizeDebounce,\n    } = this.options;\n\n\n    if (!this._maxResizeDebounceTimer && maxResizeDebounce >= resizeDebounce) {\n      this._maxResizeDebounceTimer = window.setTimeout(this._onResize, maxResizeDebounce);\n    }\n    if (this._resizeTimer) {\n      clearTimeout(this._resizeTimer);\n      this._resizeTimer = 0;\n    }\n    this._resizeTimer = window.setTimeout(this._onResize, resizeDebounce);\n  }\n\n  private _init() {\n    this._resizeContainer();\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", this._scheduleResize);\n    }\n  }\n}\n\ninterface Grid extends Properties<typeof Grid> { }\n\nexport default Grid;\n\n/**\n * Gap used to create space around items.\n * @ko 아이템들 사이의 공간.\n * @name Grid#gap\n * @type {$ts:Grid.GridOptions[\"gap\"]}\n * @example\n * import { MasonryGrid } from \"@egjs/grid\";\n *\n * const grid = new MasonryGrid(container, {\n *   gap: 0,\n * });\n *\n * grid.gap = 5;\n */\n\n/**\n * The default direction value when direction is not set in the render option.\n * @ko render옵션에서 direction을 미설정시의 기본 방향값.\n * @name Grid#defaultDirection\n * @type {$ts:Grid.GridOptions[\"defaultDirection\"]}\n * @example\n * import { MasonryGrid } from \"@egjs/grid\";\n *\n * const grid = new MasonryGrid(container, {\n *   defaultDirection: \"end\",\n * });\n *\n * grid.defaultDirection = \"start\";\n */\n","import Grid from \"../Grid\";\nimport { PROPERTY_TYPE, UPDATE_STATE } from \"../consts\";\nimport { GridOptions, Properties, GridOutlines, GridAlign } from \"../types\";\nimport { range, GetterSetter } from \"../utils\";\nimport { GridItem } from \"../GridItem\";\n\n\n/**\n * @typedef\n * @memberof Grid.MasonryGrid\n * @extends Grid.GridOptions\n * @property - The number of columns. If the number of columns is 0, it is automatically calculated according to the size of the container. <ko>열의 개수. 열의 개수가 0이라면, 컨테이너의 사이즈에 의해 계산이 된다. (default: 0) </ko>\n * @property - The size of the columns. If it is 0, it is calculated as the size of the first item in items. (default: 0) <ko> 열의 사이즈. 만약 열의 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. (default: 0) </ko>\n * @property - The size ratio(inlineSize / contentSize) of the columns. 0 is not set. (default: 0) <ko>열의 사이즈 비율(inlineSize / contentSize). 0은 미설정이다. </ko>\n * @property - Align of the position of the items. If you want to use `stretch`, be sure to set `column` or `columnSize` option. (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\") <ko>아이템들의 위치의 정렬. `stretch`를 사용하고 싶다면 `column` 또는 `columnSize` 옵션을 설정해라.  (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\")</ko>\n */\nexport interface MasonryGridOptions extends GridOptions {\n  column?: number;\n  columnSize?: number;\n  columnSizeRatio?: number;\n  align?: GridAlign;\n}\n\n/**\n * The MasonryGrid is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n *\n * @ko MasonryGrid는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 카드를 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 카드 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @memberof Grid\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {Grid.MasonryGrid.MasonryGridOptions} options - The option object of the MasonryGrid module <ko>MasonryGrid 모듈의 옵션 객체</ko>\n */\n@GetterSetter\nexport class MasonryGrid extends Grid<MasonryGridOptions> {\n  public static propertyTypes = {\n    ...Grid.propertyTypes,\n    column: PROPERTY_TYPE.RENDER_PROPERTY,\n    columnSize: PROPERTY_TYPE.RENDER_PROPERTY,\n    columnSizeRatio: PROPERTY_TYPE.RENDER_PROPERTY,\n    align: PROPERTY_TYPE.RENDER_PROPERTY,\n  };\n  public static defaultOptions: Required<MasonryGridOptions> = {\n    ...Grid.defaultOptions,\n    align: \"justify\",\n    column: 0,\n    columnSize: 0,\n    columnSizeRatio: 0,\n  };\n\n  private _columnSize = 0;\n  private _column = 1;\n\n  public applyGrid(items: GridItem[], direction: \"start\" | \"end\", outline: number[]): GridOutlines {\n    this._calculateColumnSize(items);\n    this._calculateColumn(items);\n\n    const column = this._column;\n    const columnSize = this._columnSize;\n    const {\n      gap,\n      align,\n      columnSizeRatio,\n    } = this.options;\n    const outlineLength = outline.length;\n    const itemsLength = items.length;\n    const alignPoses = this._getAlignPoses();\n    const isEndDirection = direction === \"end\";\n    const pointCalculateName = isEndDirection ? \"min\" : \"max\";\n    const indexCalculateName = isEndDirection ? \"indexOf\" : \"lastIndexOf\";\n    let startOutline = [0];\n\n    if (outlineLength === column) {\n      startOutline = outline.slice();\n    } else {\n      const point = outlineLength ? Math[pointCalculateName](...outline) : 0;\n\n      startOutline = range(column).map(() => point);\n    }\n    const endOutline = startOutline.slice();\n    const columnDist = column > 1 ? alignPoses[1] - alignPoses[0] : 0;\n    const isStretch = align === \"stretch\";\n\n    for (let i = 0; i < itemsLength; ++i) {\n      const point = Math[pointCalculateName](...endOutline) || 0;\n      let columnIndex = endOutline[indexCalculateName](point);\n      const item = items[isEndDirection ? i : itemsLength - 1 - i];\n      const columnAttribute = parseInt(item.attributes.column || \"1\", 10);\n      let inlineSize = item.inlineSize;\n      let contentSize = item.contentSize;\n      const maxColumn = Math.min(column, parseInt(item.attributes.maxColumn || \"1\", 10));\n      let itemColumn = Math.min(column, columnAttribute || Math.max(1, Math.ceil((inlineSize + gap) / columnDist)));\n\n      if (columnIndex === -1) {\n        columnIndex = 0;\n      }\n      if (column > 1 && itemColumn > 1) {\n        if (isEndDirection) {\n          // 0   columnIndex(+itemColumn)  column\n          columnIndex = Math.min(columnIndex, Math.max(0, column - itemColumn));\n        } else {\n          // 0   columnIndex(-itemColumn)  column\n          columnIndex = Math.max(columnIndex, Math.min(column - 1, itemColumn));\n        }\n      }\n      if (columnAttribute > 0) {\n        const endColumnIndex = columnIndex + (isEndDirection ? itemColumn : -itemColumn);\n        const columnOutline = outline.slice(\n          Math.min(columnIndex, endColumnIndex), Math.max(columnIndex, endColumnIndex));\n        const columnPoint = isEndDirection ? Math.max(...columnOutline) : Math.min(...columnOutline);\n\n        while (itemColumn < maxColumn) {\n          const nextEndColumnIndex = columnIndex + (isEndDirection ? itemColumn + 1 : -itemColumn - 1);\n\n          if (nextEndColumnIndex < 0 || nextEndColumnIndex > column) {\n            break;\n          }\n          if (\n            (isEndDirection && outline[nextEndColumnIndex - 1] > columnPoint)\n            || (!isEndDirection && outline[nextEndColumnIndex] < columnPoint)\n          ) {\n            break;\n          }\n          ++itemColumn;\n        }\n        if (itemColumn > 1 || isStretch) {\n          inlineSize = (itemColumn - 1) * columnDist + columnSize;\n          item.cssInlineSize = inlineSize;\n        }\n        if (columnSizeRatio > 0) {\n          contentSize = inlineSize / columnSizeRatio;\n          item.cssContentSize = contentSize;\n        }\n      }\n      const inlinePos = alignPoses[columnIndex];\n      const contentPos = isEndDirection ? point : point - gap - contentSize;\n      const endContentPos = contentPos + contentSize + gap;\n\n      item.cssInlinePos = inlinePos;\n      item.cssContentPos = contentPos;\n      const endPoint = isEndDirection ? endContentPos : contentPos;\n\n      range(itemColumn).forEach((indexOffset) => {\n        endOutline[columnIndex + (isEndDirection ? indexOffset : -indexOffset)] = endPoint;\n      });\n    }\n\n    // if end items, startOutline is low, endOutline is high\n    // if start items, startOutline is high, endOutline is low\n    return {\n      start: isEndDirection ? startOutline : endOutline,\n      end: isEndDirection ? endOutline : startOutline,\n    };\n  }\n  private _calculateColumnSize(items: GridItem[]) {\n    const {\n      columnSize: columnSizeOption,\n      gap,\n      align,\n    } = this.options;\n\n    if (align === \"stretch\") {\n      let column = this.column;\n\n      if (columnSizeOption) {\n        column = Math.max(1, Math.floor((this.getContainerInlineSize() + gap) / (columnSizeOption + gap)));\n      }\n      this._columnSize = (this.getContainerInlineSize() + gap) / (column || 1) - gap;\n    } else if (columnSizeOption) {\n      this._columnSize = columnSizeOption;\n    } else {\n      for (const item of items) {\n        const attributes = item.attributes;\n        if (item.updateState !== UPDATE_STATE.UPDATED || !item.rect || attributes.column || attributes.maxColumn) {\n          continue;\n        }\n        const inlineSize = item.inlineSize;\n\n        this._columnSize = inlineSize;\n        return inlineSize;\n      }\n      this._columnSize = this._columnSize || 0;\n    }\n    return this._columnSize;\n  }\n  private _calculateColumn(items: GridItem[]) {\n    const {\n      gap,\n      column: columnOption,\n    } = this.options;\n    const columnSize = this._columnSize;\n    let column = 1;\n\n    if (columnOption) {\n      column = columnOption;\n    } else if (!columnSize) {\n      column = 1;\n    } else {\n      column = Math.min(\n        items.length,\n        Math.max(1, Math.floor((this.getContainerInlineSize() + gap) / (columnSize + gap))),\n      );\n    }\n    this._column = column;\n    return column;\n  }\n  private _getAlignPoses() {\n    const columnSize = this._columnSize;\n    const column = this._column;\n    const {\n      align,\n      gap,\n    } = this.options;\n    const containerSize = this.getContainerInlineSize();\n    const indexes = range(column);\n\n    let offset = 0;\n    let dist = 0;\n\n    if (align === \"justify\" || align === \"stretch\") {\n      const countDist = column - 1;\n\n      dist = countDist ? Math.max((containerSize - columnSize) / countDist, columnSize + gap) : 0;\n      offset = Math.min(0, containerSize / 2 - (countDist * dist + columnSize) / 2);\n    } else {\n      dist = columnSize + gap;\n      const totalColumnSize = (column - 1) * dist + columnSize;\n\n      if (align === \"center\") {\n        offset = (containerSize - totalColumnSize) / 2;\n      } else if (align === \"end\") {\n        offset = containerSize - totalColumnSize;\n      }\n    }\n    return indexes.map((i) => {\n      return offset + i * dist;\n    });\n  }\n}\n\nexport interface MasonryGrid extends Properties<typeof MasonryGrid> {\n}\n\n\n/**\n * Align of the position of the items. If you want to use `stretch`, be sure to set `column` or `columnSize` option. (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\")\n * @ko 아이템들의 위치의 정렬. `stretch`를 사용하고 싶다면 `column` 또는 `columnSize` 옵션을 설정해라.  (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\")\n * @name Grid.MasonryGrid#align\n * @type {$ts:Grid.MasonryGrid.MasonryGridOptions[\"align\"]}\n * @example\n * import { MasonryGrid } from \"@egjs/grid\";\n *\n * const grid = new MasonryGrid(container, {\n *   align: \"start\",\n * });\n *\n * grid.align = \"justify\";\n */\n\n\n/**\n * The number of columns. If the number of columns is 0, it is automatically calculated according to the size of the container.\n * @ko 열의 개수. 열의 개수가 0이라면, 컨테이너의 사이즈에 의해 계산이 된다. (default: 0)\n * @name Grid.MasonryGrid#column\n * @type {$ts:Grid.MasonryGrid.MasonryGridOptions[\"column\"]}\n * @example\n * import { MasonryGrid } from \"@egjs/grid\";\n *\n * const grid = new MasonryGrid(container, {\n *   column: 0,\n * });\n *\n * grid.column = 4;\n */\n\n\n/**\n * The size of the columns. If it is 0, it is calculated as the size of the first item in items. (default: 0)\n * @ko 열의 사이즈. 만약 열의 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. (default: 0)\n * @name Grid.MasonryGrid#columnSize\n * @type {$ts:Grid.MasonryGrid.MasonryGridOptions[\"columnSize\"]}\n * @example\n * import { MasonryGrid } from \"@egjs/grid\";\n *\n * const grid = new MasonryGrid(container, {\n *   columnSize: 0,\n * });\n *\n * grid.columnSize = 200;\n */\n\n\n/**\n * The size ratio(inlineSize / contentSize) of the columns. 0 is not set. (default: 0)\n * @ko 열의 사이즈 비율(inlineSize / contentSize). 0은 미설정이다.\n * @name Grid.MasonryGrid#columnSizeRatio\n * @type {$ts:Grid.MasonryGrid.MasonryGridOptions[\"columnSizeRatio\"]}\n * @example\n * import { MasonryGrid } from \"@egjs/grid\";\n *\n * const grid = new MasonryGrid(container, {\n *   columnSizeRatio: 0,\n * });\n *\n * grid.columnSizeRatio = 0.5;\n */\n","/* eslint-disable */\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nfunction single_source_shortest_paths(\n\tgraph: (x: string) => ({ [key: string]: number }),\n\ts: string,\n\td: string,\n) {\n\t// Predecessor map for each node that has been encountered.\n\t// node ID => predecessor node ID\n\tconst predecessors: { [key: string]: string } = {};\n\t// Costs of shortest paths from s to all nodes encountered.\n\t// node ID => cost\n\tconst costs: { [key: string]: number } = {};\n\tcosts[s] = 0;\n\n\t// Costs of shortest paths from s to all nodes encountered; differs from\n\t// `costs` in that it provides easy access to the node that currently has\n\t// the known shortest path from s.\n\t// XXX: Do we actually need both `costs` and `open`?\n\tconst open = new BinaryHeap<{ value: string, cost: number }>(x => x.cost);\n\topen.push({ value: s, cost: 0 });\n\n\tlet closest;\n\tlet u;\n\tlet cost_of_s_to_u;\n\tlet adjacent_nodes;\n\tlet cost_of_e;\n\tlet cost_of_s_to_u_plus_cost_of_e;\n\tlet cost_of_s_to_v;\n\tlet first_visit: boolean;\n\n\twhile (open.size()) {\n\t\t// In the nodes remaining in graph that have a known cost from s,\n\t\t// find the node, u, that currently has the shortest path from s.\n\t\tclosest = open.pop();\n\t\tu = closest.value;\n\t\tcost_of_s_to_u = closest.cost;\n\n\t\t// Get nodes adjacent to u...\n\t\tadjacent_nodes = graph(u) || {};\n\n\t\t// ...and explore the edges that connect u to those nodes, updating\n\t\t// the cost of the shortest paths to any or all of those nodes as\n\t\t// necessary. v is the node across the current edge from u.\n\t\tfor (const v in adjacent_nodes) {\n\t\t\t// Get the cost of the edge running from u to v.\n\t\t\tcost_of_e = adjacent_nodes[v];\n\n\t\t\t// Cost of s to u plus the cost of u to v across e--this is *a*\n\t\t\t// cost from s to v that may or may not be less than the current\n\t\t\t// known cost to v.\n\t\t\tcost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n\t\t\t// If we haven't visited v yet OR if the current known cost from s to\n\t\t\t// v is greater than the new cost we just found (cost of s to u plus\n\t\t\t// cost of u to v across e), update v's cost in the cost list and\n\t\t\t// update v's predecessor in the predecessor list (it's now u).\n\t\t\tcost_of_s_to_v = costs[v];\n\t\t\tfirst_visit = (typeof costs[v] === \"undefined\");\n\t\t\tif (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n\t\t\t\tcosts[v] = cost_of_s_to_u_plus_cost_of_e;\n\t\t\t\topen.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });\n\t\t\t\tpredecessors[v] = u;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof costs[d] === \"undefined\") {\n\t\tconst msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n\t\tthrow new Error(msg);\n\t}\n\n\treturn predecessors;\n}\nfunction extract_shortest_path_from_predecessor_list(\n\tpredecessors: { [key: string]: string },\n\td: string,\n) {\n\tconst nodes: string[] = [];\n\tlet u = d;\n\n\twhile (u) {\n\t\tnodes.push(u);\n\t\tu = predecessors[u];\n\t}\n\tnodes.reverse();\n\treturn nodes;\n}\nfunction find_path(\n\tgraph: (x: string) => ({ [key: string]: number }),\n\ts: string,\n\td: string,\n) {\n\tconst predecessors = single_source_shortest_paths(graph, s, d);\n\n\treturn extract_shortest_path_from_predecessor_list(predecessors, d);\n}\n\nclass BinaryHeap<T> {\n\tprivate content: T[];\n\tprivate scoreFunction: (x: T) => number;\n\n\tconstructor(scoreFunction: (x: T) => number) {\n\t\tthis.content = [];\n\t\tthis.scoreFunction = scoreFunction;\n\t}\n\tpublic push(element: T) {\n\t\t// Add the new element to the end of the array.\n\t\tthis.content.push(element);\n\t\t// Allow it to bubble up.\n\t\tthis.bubbleUp(this.content.length - 1);\n\t}\n\tpublic pop() {\n\t\t// Store the first element so we can return it later.\n\t\tconst result = this.content[0];\n\t\t// Get the element at the end of the array.\n\t\tconst end = this.content.pop()!;\n\t\t// If there are any elements left, put the end element at the\n\t\t// start, and let it sink down.\n\t\tif (this.content.length > 0) {\n\t\t\tthis.content[0] = end;\n\t\t\tthis.sinkDown(0);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic size() {\n\t\treturn this.content.length;\n\t}\n\tpublic bubbleUp(_n: number) {\n\t\tlet n = _n;\n\t\t// Fetch the element that has to be moved.\n\t\tconst element = this.content[n];\n\t\t// When at 0, an element can not go up any further.\n\t\twhile (n > 0) {\n\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\tconst parentN = Math.floor((n + 1) / 2) - 1;\n\t\t\tconst parent = this.content[parentN];\n\n\t\t\t// Swap the elements if the parent is greater.\n\t\t\tif (this.scoreFunction(element) < this.scoreFunction(parent)) {\n\t\t\t\tthis.content[parentN] = element;\n\t\t\t\tthis.content[n] = parent;\n\t\t\t\t// Update 'n' to continue at the new position.\n\t\t\t\tn = parentN;\n\t\t\t} else {\n\t\t\t\t// Found a parent that is less, no need to move it further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic sinkDown(n: number) {\n\t\t// Look up the target element and its score.\n\t\tconst length = this.content.length;\n\t\tconst element = this.content[n];\n\t\tconst elemScore = this.scoreFunction(element);\n\t\tlet child1Score;\n\n\t\twhile (true) {\n\t\t\t// Compute the indices of the child elements.\n\t\t\tconst child2N = (n + 1) * 2;\n\t\t\tconst child1N = child2N - 1;\n\t\t\t// This is used to store the new position of the element,\n\t\t\t// if any.\n\t\t\tlet swap: number | null = null;\n\t\t\t// If the first child exists (is inside the array)...\n\t\t\tif (child1N < length) {\n\t\t\t\t// Look it up and compute its score.\n\t\t\t\tconst child1 = this.content[child1N];\n\t\t\t\tchild1Score = this.scoreFunction(child1);\n\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\tif (child1Score < elemScore) {\n\t\t\t\t\tswap = child1N;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do the same checks for the other child.\n\t\t\tif (child2N < length) {\n\t\t\t\tconst child2 = this.content[child2N];\n\t\t\t\tconst child2Score = this.scoreFunction(child2);\n\n\t\t\t\tif (child2Score < (swap == null ? elemScore : child1Score)) {\n\t\t\t\t\tswap = child2N;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the element needs to be moved, swap it, and continue.\n\t\t\tif (swap !== null) {\n\t\t\t\tthis.content[n] = this.content[swap];\n\t\t\t\tthis.content[swap] = element;\n\t\t\t\tn = swap;\n\t\t\t} else {\n\t\t\t\t// Otherwise, we are done.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { find_path };\n","import Grid from \"../Grid\";\nimport { PROPERTY_TYPE } from \"../consts\";\nimport { GridOptions, Properties, GridOutlines } from \"../types\";\nimport { getRangeCost, GetterSetter, isObject } from \"../utils\";\nimport { find_path } from \"./lib/dijkstra\";\nimport { GridItem } from \"../GridItem\";\n\n\ninterface Link {\n  path: number[];\n  cost: number;\n  length: number;\n  currentNode: number;\n  isOver?: boolean;\n}\n\n/**\n * @typedef\n * @memberof Grid.JustifiedGrid\n * @extends Grid.GridOptions\n * @property - The minimum and maximum number of items per line. (default: [1, 8]) <ko> 한 줄에 들어가는 아이템의 최소, 최대 개수. (default: [1, 8]) </ko>\n * @property - The minimum and maximum number of rows in a group, 0 is not set. (default: 0) <ko> 한 그룹에 들어가는 행의 최소, 최대 개수, 0은 미설정이다. (default: 0) </ko>\n * @property - The minimum and maximum size by which the item is adjusted. If it is not calculated, it may deviate from the minimum and maximum sizes. (default: [0, Infinity]) <ko>아이템이 조정되는 최소, 최대 사이즈. 계산이 되지 않는 경우 최소, 최대 사이즈를 벗어날 수 있다. (default: [0, Infinity])</ko>\n */\nexport interface JustifiedGridOptions extends GridOptions {\n  columnRange?: number | number[];\n  rowRange?: number | number[];\n  sizeRange?: number[];\n}\n\n/**\n * 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedGrid is a grid that the card is filled up on the basis of a line given a size.\n * @ko 'justified'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. JustifiedGrid는 용어의 의미대로 너비가 주어진 사이즈를 기준으로 카드가 가득 차도록 배치하는 Grid다.\n * @memberof Grid\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {Grid.JustifiedGrid.JustifiedGridOptions} options - The option object of the JustifiedGrid module <ko>JustifiedGrid 모듈의 옵션 객체</ko>\n */\n@GetterSetter\nexport class JustifiedGrid extends Grid<JustifiedGridOptions> {\n  public static propertyTypes = {\n    ...Grid.propertyTypes,\n    columnRange: PROPERTY_TYPE.RENDER_PROPERTY,\n    rowRange: PROPERTY_TYPE.RENDER_PROPERTY,\n    sizeRange: PROPERTY_TYPE.RENDER_PROPERTY,\n  };\n  public static defaultOptions: Required<JustifiedGridOptions> = {\n    ...Grid.defaultOptions,\n    columnRange: [1, 8],\n    rowRange: 0,\n    sizeRange: [0, Infinity],\n  };\n\n  public applyGrid(items: GridItem[], direction: \"start\" | \"end\", outline: number[]): GridOutlines {\n    const rowRange = this.options.rowRange;\n    let path: string[] = [];\n\n    if (items.length) {\n      path = rowRange ? this._getRowPath(items) : this._getPath(items);\n    }\n    return this._setStyle(items, path, outline, direction === \"end\");\n  }\n  private _getRowPath(items: GridItem[]) {\n    const {\n      columnRange: columnRangeOption,\n      rowRange: rowRangeOption,\n    } = this.options;\n    const columnRange = isObject(columnRangeOption) ? columnRangeOption : [columnRangeOption, columnRangeOption];\n    const rowRange: number[] = isObject(rowRangeOption) ? rowRangeOption : [rowRangeOption, rowRangeOption];\n    const pathLink = this._getRowLink(items, {\n      path: [0],\n      cost: 0,\n      length: 0,\n      currentNode: 0,\n    }, columnRange, rowRange);\n\n    return pathLink?.path.map((node) => `${node}`) ?? [];\n  }\n  private _getRowLink(\n    items: GridItem[],\n    currentLink: Link,\n    columnRange: number[],\n    rowRange: number[]\n  ): Link {\n    const [minColumn] = columnRange;\n    const [minRow, maxRow] = rowRange;\n    const lastNode = items.length;\n    const {\n      path,\n      length: pathLength,\n      cost,\n      currentNode,\n    } = currentLink;\n\n    // not reached lastNode but path is exceed or the number of remaining nodes is less than minColumn.\n    if (currentNode < lastNode && (maxRow <= pathLength || currentNode + minColumn > lastNode)) {\n      const rangeCost = getRangeCost(lastNode - currentNode, columnRange);\n      const lastCost = rangeCost * Math.abs(this._getCost(items, currentNode, lastNode));\n\n      return {\n        ...currentLink,\n        length: pathLength + 1,\n        path: [...path, lastNode],\n        currentNode: lastNode,\n        cost: cost + lastCost,\n        isOver: true,\n      };\n    } else if (currentNode >= lastNode) {\n      return {\n        ...currentLink,\n        currentNode: lastNode,\n        isOver: minRow > pathLength || maxRow < pathLength,\n      };\n    } else {\n      return this._searchRowLink(items, currentLink, lastNode, columnRange, rowRange);\n    }\n\n  }\n  private _searchRowLink(\n    items: GridItem[],\n    currentLink: Link,\n    lastNode: number,\n    columnRange: number[],\n    rowRange: number[]\n  ) {\n    const [minColumn, maxColumn] = columnRange;\n    const {\n      currentNode,\n      path,\n      length: pathLength,\n      cost,\n    } = currentLink;\n    const length = Math.min(lastNode, currentNode + maxColumn);\n    const links: Link[] = [];\n\n    for (let nextNode = currentNode + minColumn; nextNode <= length; ++nextNode) {\n      if (nextNode === currentNode) {\n        continue;\n      }\n      const nextCost = Math.abs(this._getCost(items, currentNode, nextNode));\n      const nextLink = this._getRowLink(items, {\n        path: [...path, nextNode],\n        length: pathLength + 1,\n        cost: cost + nextCost,\n        currentNode: nextNode,\n      }, columnRange, rowRange);\n\n      if (nextLink) {\n        links.push(nextLink);\n      }\n    }\n    links.sort((a, b) => {\n      const aIsOver = a.isOver;\n      const bIsOver = b.isOver;\n\n      if (aIsOver !== bIsOver) {\n        // If it is over, the cost is high.\n        return aIsOver ? 1 : -1;\n      }\n      const aRangeCost = getRangeCost(a.length, rowRange);\n      const bRangeCost = getRangeCost(b.length, rowRange);\n\n      return aRangeCost - bRangeCost || a.cost - b.cost;\n    });\n\n    // It returns the lowest cost link.\n    return links[0];\n  }\n  private _getSize(items: GridItem[]) {\n    const {\n      gap,\n    } = this.options;\n    const size = items.reduce((sum, item) => {\n      const inlineSize = item.orgInlineSize;\n      const contentSize = item.orgContentSize;\n\n      if (!inlineSize || !contentSize) {\n        return sum;\n      }\n      return sum + inlineSize / contentSize;\n    }, 0);\n\n    return size ? (this.getContainerInlineSize()! - gap * (items.length - 1)) / size : 0;\n  }\n  private _getCost(\n    items: GridItem[],\n    i: number,\n    j: number,\n  ) {\n    const size = this._getSize(items.slice(i, j));\n    const [minSize, maxSize] = this.options.sizeRange;\n\n    if (isFinite(maxSize)) {\n      // if this size is not in range, the cost increases sharply.\n      if (size < minSize) {\n        return Math.pow(size - minSize, 2) + Math.pow(maxSize, 2);\n      } else if (size > maxSize) {\n        return Math.pow(size - maxSize, 2) + Math.pow(maxSize, 2);\n      }\n    } else if (size < minSize) {\n      return Math.max(Math.pow(minSize, 2), Math.pow(size, 2)) + Math.pow(maxSize, 2);\n    }\n    // if this size in range, the cost is row\n    return size - minSize;\n  }\n  private _getPath(items: GridItem[]) {\n    const lastNode = items.length;\n    const columnRangeOption = this.options.columnRange;\n    const [minColumn, maxColumn]: number[] = isObject(columnRangeOption)\n      ? columnRangeOption\n      : [columnRangeOption, columnRangeOption];\n\n    const graph = (nodeKey: string) => {\n      const results: { [key: string]: number } = {};\n      const currentNode = parseInt(nodeKey, 10);\n\n      for (let nextNode = Math.min(currentNode + minColumn, lastNode); nextNode <= lastNode; ++nextNode) {\n        if (nextNode - currentNode > maxColumn) {\n          break;\n        }\n        let cost = this._getCost(\n          items,\n          currentNode,\n          nextNode,\n        );\n\n        if (cost < 0 && nextNode === lastNode) {\n          cost = 0;\n        }\n        results[`${nextNode}`] = Math.pow(cost, 2);\n      }\n      return results;\n    };\n    // shortest path for items' total height.\n    return find_path(graph, \"0\", `${lastNode}`);\n  }\n  private _setStyle(\n    items: GridItem[],\n    path: string[],\n    outline: number[] = [],\n    isEndDirection: boolean,\n  ) {\n    const {\n      gap,\n    } = this.options;\n    const length = path.length;\n    const startPoint = outline[0] || 0;\n    let contentPos = startPoint;\n\n    for (let i = 0; i < length - 1; ++i) {\n      const path1 = parseInt(path[i], 10);\n      const path2 = parseInt(path[i + 1], 10);\n      // pathItems(path1 to path2) are in 1 line.\n      const pathItems = items.slice(path1, path2);\n      const pathItemsLength = pathItems.length;\n      const contentSize = this._getSize(pathItems);\n\n      for (let j = 0; j < pathItemsLength; ++j) {\n        const item = pathItems[j];\n        const inlineSize = item.orgInlineSize / item.orgContentSize * contentSize;\n        const prevItem = pathItems[j - 1];\n        const inlinePos = prevItem\n          ? prevItem.cssInlinePos + prevItem.cssInlineSize + gap\n          : 0;\n\n\n        item.setCSSGridRect({\n          inlinePos,\n          contentPos,\n          inlineSize,\n          contentSize,\n        });\n      }\n      contentPos += gap + contentSize;\n    }\n\n    if (isEndDirection) {\n      // previous group's end outline is current group's start outline\n      return {\n        start: [startPoint],\n        end: [contentPos],\n      };\n    }\n    // always start is lower than end.\n    // contentPos is endPoinnt\n    const height = contentPos - startPoint;\n\n    items.forEach((item) => {\n      item.cssContentPos -= height;\n    });\n    return {\n      start: [startPoint - height],\n      end: [startPoint], // endPoint - height = startPoint\n    };\n  }\n}\n\nexport interface JustifiedGrid extends Properties<typeof JustifiedGrid> {\n}\n\n\n/**\n * The minimum and maximum number of items per line. (default: [1, 8])\n * @ko 한 줄에 들어가는 아이템의 최소, 최대 개수. (default: [1, 8])\n * @name Grid.JustifiedGrid#columnRange\n * @type {$ts:Grid.JustifiedGrid.JustifiedGridOptions[\"columnRange\"]}\n * @example\n * import { JustifiedGrid } from \"@egjs/grid\";\n *\n * const grid = new JustifiedGrid(container, {\n *   columnRange: [1, 8],\n * });\n *\n * grid.columnRange = [3, 6];\n */\n\n\n/**\n * The minimum and maximum number of rows in a group, 0 is not set. (default: 0)\n * @ko 한 그룹에 들어가는 행의 최소, 최대 개수, 0은 미설정이다. (default: 0)\n * @name Grid.JustifiedGrid#rowRange\n * @type {$ts:Grid.JustifiedGrid.JustifiedGridOptions[\"rowRange\"]}\n * @example\n * import { JustifiedGrid } from \"@egjs/grid\";\n *\n * const grid = new JustifiedGrid(container, {\n *   rowRange: 0,\n * });\n *\n * grid.rowRange = [3, 4];\n */\n\n/**\n * The minimum and maximum size by which the item is adjusted. If it is not calculated, it may deviate from the minimum and maximum sizes. (default: [0, Infinity])\n * @ko 아이템이 조정되는 최소, 최대 사이즈. 계산이 되지 않는 경우 최소, 최대 사이즈를 벗어날 수 있다. (default: [0, Infinity])\n * @name Grid.JustifiedGrid#sizeRange\n * @type {$ts:Grid.JustifiedGrid.JustifiedGridOptions[\"sizeRange\"]}\n * @example\n * import { JustifiedGrid } from \"@egjs/grid\";\n *\n * const grid = new JustifiedGrid(container, {\n *   sizeRange: [0, Infinity],\n * });\n *\n * grid.sizeRange = [200, 800];\n */\n","import Grid from \"../Grid\";\nimport { PROPERTY_TYPE } from \"../consts\";\nimport { GridOptions, Properties, GridOutlines, GridRect } from \"../types\";\nimport { GetterSetter, range } from \"../utils\";\nimport { GridItem } from \"../GridItem\";\n\n\nfunction getMaxPoint(outline: number[]) {\n  let maxPoint = -Infinity;\n\n  outline.forEach((point) => {\n    if (isFinite(point)) {\n      maxPoint = Math.max(maxPoint, point);\n    }\n  });\n  return isFinite(maxPoint) ? maxPoint : 0;\n}\nfunction getMinPoint(outline: number[]) {\n  let minPoint = Infinity;\n\n  outline.forEach((point) => {\n    if (isFinite(point)) {\n      minPoint = Math.min(minPoint, point);\n    }\n  });\n  return isFinite(minPoint) ? minPoint : 0;\n}\nfunction getOutlinePoint(startOutline: number[], frameOutline: number[], useFrameFill: boolean) {\n  return getMaxPoint(startOutline)\n    + getOutlineDist(startOutline, frameOutline, useFrameFill);\n}\n\nfunction getOutlineDist(startOutline: number[], endOutline: number[], useFrameFill: boolean) {\n  const length = startOutline.length;\n\n  if (!length) {\n    return 0;\n  }\n  const minEndPoint = getMinPoint(endOutline);\n  const maxStartPoint = getMaxPoint(startOutline);\n  let frameDist = 0;\n\n  if (!useFrameFill) {\n    return 0;\n  }\n\n\n  for (let outlineIndex = 0; outlineIndex < length; ++outlineIndex) {\n    const startPoint = startOutline[outlineIndex];\n    const endPoint = endOutline[outlineIndex];\n\n    if (!isFinite(startPoint) || !isFinite(endPoint)) {\n      continue;\n    }\n    const startPos = startPoint - maxStartPoint;\n    const endPos = endPoint - minEndPoint;\n\n\n    // Fill empty block.\n    frameDist = outlineIndex ? Math.max(frameDist, frameDist + startPos - endPos) : startPos - endPos;\n  }\n\n  return frameDist;\n}\nfunction fillOutlines(startOutline: number[], endOutline: number[], rect: {\n  inlinePos: number;\n  inlineSize: number;\n  contentPos: number;\n  contentSize: number;\n}) {\n  const {\n    inlinePos,\n    inlineSize,\n    contentPos,\n    contentSize,\n  } = rect;\n  for (\n    let outlineIndex = inlinePos;\n    outlineIndex < inlinePos + inlineSize;\n    ++outlineIndex\n  ) {\n    startOutline[outlineIndex] = Math.min(startOutline[outlineIndex], contentPos);\n    endOutline[outlineIndex] = Math.max(endOutline[outlineIndex], contentPos + contentSize);\n  }\n}\nexport interface FrameRect extends Required<GridRect> {\n  type: any;\n}\n/**\n * @typedef\n * @memberof Grid.FrameGrid\n * @extends Grid.GridOptions\n * @property - The shape of the Grid. You can set the shape of the item as a 2d array. 0 and \"\" are empty spaces, and the order of items is determined in ascending order. (default: []) <ko>Grid의 모양. 2d 배열로 아이템의 모양을 설정할 수 있다. 0과 \"\"은 공백이며 아이템의 순서는 오름차순으로 결정된다. (default: [])</ko>\n * @property - Make sure that the frame can be attached after the previous frame. (default: true) <ko> 다음 프레임이 전 프레임에 이어 붙일 수 있는지 있는지 확인한다.</ko>\n * @property - 1x1 rect size. If it is 0, it is determined by the number of columns in the frame. (default: 0) <ko>1x1 직사각형 크기. 0이면 frame의 column의 개수에 의해 결정된다. (default: 0)</ko>\n */\nexport interface FrameGridOptions extends GridOptions {\n  frame?: number[][];\n  useFrameFill?: boolean;\n  rectSize?: number | { inlineSize: number, contentSize: number };\n}\n\n/**\n * 'Frame' is a printing term with the meaning that 'it fits in one row wide'. FrameGrid is a grid that the card is filled up on the basis of a line given a size.\n * @ko 'Frame'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. FrameGrid는 용어의 의미대로 너비가 주어진 사이즈를 기준으로 카드가 가득 차도록 배치하는 Grid다.\n * @memberof Grid\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {Grid.FrameGrid.FrameGridOptions} options - The option object of the FrameGrid module <ko>FrameGrid 모듈의 옵션 객체</ko>\n */\n@GetterSetter\nexport class FrameGrid extends Grid<FrameGridOptions> {\n  public static propertyTypes = {\n    ...Grid.propertyTypes,\n    frame: PROPERTY_TYPE.RENDER_PROPERTY,\n    useFrameFill: PROPERTY_TYPE.RENDER_PROPERTY,\n    rectSize: PROPERTY_TYPE.RENDER_PROPERTY,\n  };\n  public static defaultOptions: Required<FrameGridOptions> = {\n    ...Grid.defaultOptions,\n    frame: [],\n    rectSize: 0,\n    useFrameFill: true,\n  };\n\n  public applyGrid(items: GridItem[], direction: \"start\" | \"end\", outline: number[]): GridOutlines {\n    const frame = this._getFrame();\n    const {\n      inlineSize: frameInlineSize,\n      contentSize: frameContentSize,\n      rects: frameRects,\n    } = frame;\n    const {\n      gap,\n      useFrameFill,\n    } = this.options;\n\n    const {\n      inlineSize: rectInlineSize,\n      contentSize: rectContentSize,\n    } = this.getRectSize(frameInlineSize);\n\n\n    const itemsLength = items.length;\n\n    if (!itemsLength || !frameInlineSize || !frameContentSize) {\n      return { start: outline, end: outline };\n    }\n    const rectsLength = frameRects.length;\n    let startOutline = range(frameInlineSize).map(() => Infinity);\n    let endOutline = range(frameInlineSize).map(() => -Infinity);\n    const frameOutline = frame.outline.map((point) => point * (rectContentSize + gap));\n\n    for (let startIndex = 0; startIndex < itemsLength; startIndex += rectsLength) {\n      // Compare group's startOutline and startOutline of rect\n      const startPoint = getOutlinePoint(endOutline, frameOutline, useFrameFill);\n\n      for (let rectIndex = 0; rectIndex < rectsLength && startIndex + rectIndex < itemsLength; ++rectIndex) {\n        const item = items[startIndex + rectIndex];\n        const {\n          contentPos: frameRectContentPos,\n          inlinePos: frameRectInlinePos,\n          contentSize: frameRectContentSize,\n          inlineSize: frameRectInlineSize,\n        } = frameRects[rectIndex];\n        const contentPos = startPoint + frameRectContentPos * (rectContentSize + gap);\n        const inlinePos = frameRectInlinePos * (rectInlineSize + gap);\n        const contentSize = frameRectContentSize * (rectContentSize + gap) - gap;\n        const inlineSize = frameRectInlineSize * (rectInlineSize + gap) - gap;\n\n        fillOutlines(startOutline, endOutline, {\n          inlinePos: frameRectInlinePos,\n          inlineSize: frameRectInlineSize,\n          contentPos: contentPos,\n          contentSize: contentSize + gap,\n        });\n        item.setCSSGridRect({\n          inlinePos,\n          contentPos,\n          inlineSize,\n          contentSize,\n        });\n      }\n    }\n    const isDirectionEnd = direction === \"end\";\n\n    let gridOutline = outline;\n\n    if (gridOutline.length !== frameInlineSize) {\n      const point = isDirectionEnd ? Math.max(...gridOutline) : Math.min(...gridOutline);\n\n      gridOutline = range(frameInlineSize).map(() => point);\n    }\n    startOutline = startOutline.map((point) => isFinite(point) ? point : 0);\n    endOutline = endOutline.map((point) => isFinite(point) ? point : 0);\n    const outlineDist = isDirectionEnd\n      ? getOutlineDist(startOutline, gridOutline, useFrameFill)\n      : getOutlineDist(gridOutline, endOutline, useFrameFill);\n\n    items.forEach((item) => {\n      item.cssContentPos += outlineDist;\n    });\n\n    return {\n      start: startOutline.map((point) => point + outlineDist),\n      end: endOutline.map((point) => point + outlineDist),\n    };\n  }\n  protected getRectSize(frameInlineSize: number) {\n    const {\n      gap,\n      rectSize: rectSizeOption,\n    } = this.options;\n\n    if (typeof rectSizeOption === \"object\") {\n      return rectSizeOption;\n    }\n    const rectSizeValue = rectSizeOption\n      ? rectSizeOption\n      : (this.getContainerInlineSize()! + gap) / frameInlineSize - gap;\n\n    return { inlineSize: rectSizeValue, contentSize: rectSizeValue };\n  }\n  private _getFrame() {\n    const frame = this.options.frame;\n    const frameContentSize = frame.length;\n    const frameInlineSize = frameContentSize ? frame[0].length : 0;\n    const rects: FrameRect[] = [];\n    const passMap: Record<string, boolean> = {};\n    const startOutline = range(frameInlineSize).map(() => Infinity);\n    const endOutline = range(frameInlineSize).map(() => -Infinity);\n\n    for (let y1 = 0; y1 < frameContentSize; ++y1) {\n      for (let x1 = 0; x1 < frameInlineSize; ++x1) {\n        const type = frame[y1][x1];\n\n        if (!type) {\n          continue;\n        }\n        if (passMap[`${y1},${x1}`]) {\n          continue;\n        }\n        const rect = this._findRect(passMap, type, y1, x1, frameInlineSize, frameContentSize);\n\n        fillOutlines(startOutline, endOutline, rect);\n        rects.push(rect);\n      }\n    }\n    rects.sort((a, b) => (a.type < b.type ? -1 : 1));\n\n\n    return {\n      rects,\n      inlineSize: frameInlineSize,\n      contentSize: frameContentSize,\n      outline: startOutline,\n    };\n  }\n  private _findRect(\n    passMap: Record<string, boolean>,\n    type: number,\n    y1: number,\n    x1: number,\n    frameInlineSize: number,\n    frameContentSize: number,\n  ) {\n    const frame = this.options.frame;\n\n    let contentSize = 1;\n    let inlineSize = 1;\n\n    // find rect\n    for (let x2 = x1; x2 < frameInlineSize; ++x2) {\n      if (frame[y1][x2] === type) {\n        inlineSize = x2 - x1 + 1;\n        continue;\n      }\n      break;\n    }\n    for (let y2 = y1; y2 < frameContentSize; ++y2) {\n      if (frame[y2][x1] === type) {\n        contentSize = y2 - y1 + 1;\n        continue;\n      }\n      break;\n    }\n\n    // pass rect\n    for (let y = y1; y < y1 + contentSize; ++y) {\n      for (let x = x1; x < x1 + inlineSize; ++x) {\n        passMap[`${y},${x}`] = true;\n      }\n    }\n\n    const rect: FrameRect = {\n      type,\n      inlinePos: x1,\n      contentPos: y1,\n      inlineSize,\n      contentSize,\n    };\n    return rect;\n  }\n}\n\nexport interface FrameGrid extends Properties<typeof FrameGrid> {\n}\n\n\n/**\n * The shape of the Grid. You can set the shape of the item as a 2d array. 0 and space are empty spaces, and the order of items is determined in ascending order. (default: [])\n * @ko grid의 모양. 2d 배열로 아이템의 모양을 설정할 수 있다. 0과 공백은 빈 공간이며 아이템의 순서는 오름차순으로 결정된다. (default: [])\n * @name Grid.FrameGrid#frame\n * @type {$ts:Grid.FrameGrid.FrameGridOptions[\"frame\"]}\n * @example\n * import { FrameGrid } from \"@egjs/grid\";\n *\n * const grid = new FrameGrid(container, {\n *   frame: [\n *     [1, 1, 0, 0, 2, 3],\n *     [1, 1, 0, 4, 5, 5],\n *   ],\n * });\n *\n * grid.frame = [\n *   [1, 1, 0, 0, 2, 2],\n *   [1, 1, 0, 0, 2, 2],\n * ];\n */\n\n/**\n * Make sure that the frame can be attached after the previous frame. (default: true)\n * @ko 다음 프레임이 전 프레임에 이어 붙일 수 있는지 있는지 확인한다. (default: true)\n * @name Grid.FrameGrid#useFrameFill\n * @type {$ts:Grid.FrameGrid.FrameGridOptions[\"useFrameFill\"]}\n * @example\n * import { FrameGrid } from \"@egjs/grid\";\n *\n * const grid = new FrameGrid(container, {\n *   useFrameFill: true,\n * });\n *\n * grid.useFrameFill = false;\n */\n\n/**\n * 1x1 rect size. If it is 0, it is determined by the number of columns in the frame. (default: 0)\n * @ko 1x1 직사각형 크기. 0이면 frame의 column의 개수에 의해 결정된다. (default: 0)\n * @name Grid.FrameGrid#rectSize\n * @type {$ts:Grid.FrameGrid.FrameGridOptions[\"rectSize\"]}\n * @example\n * import { FrameGrid } from \"@egjs/grid\";\n *\n * const grid = new FrameGrid(container, {\n *   rectSize: 0,\n * });\n *\n * grid.rectSize = { inlineSize: 100, contentSize: 150 };\n */\n","export interface BoxModelStatus {\n  orgInlineSize: number;\n  orgContentSize: number;\n  inlineSize: number;\n  contentSize: number;\n  inlinePos: number;\n  contentPos: number;\n  items: BoxModel[];\n}\n\nexport default class BoxModel implements BoxModelStatus {\n  public orgInlineSize: number;\n  public orgContentSize: number;\n  public inlineSize: number;\n  public contentSize: number;\n  public inlinePos: number;\n  public contentPos: number;\n  public items: BoxModel[];\n  constructor(status: Partial<BoxModelStatus>) {\n    const boxStatus = {\n      orgInlineSize: 0,\n      orgContentSize: 0,\n      inlineSize: 0,\n      contentSize: 0,\n      inlinePos: 0,\n      contentPos: 0,\n      items: [],\n      ...status,\n    };\n    for (const name in boxStatus) {\n      this[name] = boxStatus[name];\n    }\n  }\n  public scaleTo(inlineSize: number, contentSize: number) {\n    const scaleX = this.inlineSize ? inlineSize / this.inlineSize : 0;\n    const scaleY = this.contentSize ? contentSize / this.contentSize : 0;\n\n    this.items.forEach((item) => {\n      if (scaleX !== 0) {\n        item.inlinePos *= scaleX;\n        item.inlineSize *= scaleX;\n      }\n      if (scaleY !== 0) {\n        item.contentPos *= scaleY;\n        item.contentSize *= scaleY;\n      }\n    });\n\n    this.inlineSize = inlineSize;\n    this.contentSize = contentSize;\n  }\n  public push(item: BoxModel) {\n    this.items.push(item);\n  }\n  public getOrgSizeWeight() {\n    return this.orgInlineSize * this.orgContentSize;\n  }\n  public getSize() {\n    return this.inlineSize * this.contentSize;\n  }\n  public getOrgRatio() {\n    return (this.orgContentSize === 0) ? 0 : this.orgInlineSize / this.orgContentSize;\n  }\n  public getRatio() {\n    return (this.contentSize === 0) ? 0 : this.inlineSize / this.contentSize;\n  }\n}\n","import Grid from \"../Grid\";\nimport { PROPERTY_TYPE } from \"../consts\";\nimport { GridOptions, Properties, GridOutlines } from \"../types\";\nimport { GetterSetter } from \"../utils\";\nimport { GridItem } from \"../GridItem\";\nimport BoxModel from \"./lib/BoxModel\";\n\n\nfunction getCost(originLength: number, length: number) {\n  let cost = originLength / length;\n\n  if (cost < 1) {\n    cost = 1 / cost;\n  }\n\n  return cost - 1;\n}\nfunction fitArea(\n  item: BoxModel,\n  bestFitArea: BoxModel,\n  itemFitSize: { inlineSize: number, contentSize: number },\n  containerFitSize: { inlineSize: number, contentSize: number },\n  isContentDirection: boolean,\n) {\n  item.contentSize = itemFitSize.contentSize;\n  item.inlineSize = itemFitSize.inlineSize;\n  bestFitArea.contentSize = containerFitSize.contentSize;\n  bestFitArea.inlineSize = containerFitSize.inlineSize;\n\n  if (isContentDirection) {\n    item.contentPos = bestFitArea.contentPos + bestFitArea.contentSize;\n    item.inlinePos = bestFitArea.inlinePos;\n  } else {\n    item.inlinePos = bestFitArea.inlinePos + bestFitArea.inlineSize;\n    item.contentPos = bestFitArea.contentPos;\n  }\n}\n\n\n/**\n * @typedef\n * @memberof Grid.PackingGrid\n * @extends Grid.GridOptions\n * @property - The number of columns. If the number of columns is 0, it is automatically calculated according to the size of the container. <ko>열의 개수. 열의 개수가 0이라면, 컨테이너의 사이즈에 의해 계산이 된다. (default: 0) </ko>\n * @property - The size of the columns. If it is 0, it is calculated as the size of the first item in items. (default: 0) <ko> 열의 사이즈. 만약 열의 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. (default: 0) </ko>\n * @property - The size ratio(inlineSize / contentSize) of the columns. 0 is not set. (default: 0) <ko>열의 사이즈 비율(inlineSize / contentSize). 0은 미설정이다. </ko>\n * @property - Align of the position of the items. If you want to use `stretch`, be sure to set `column` or `columnSize` option. (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\") <ko>아이템들의 위치의 정렬. `stretch`를 사용하고 싶다면 `column` 또는 `columnSize` 옵션을 설정해라.  (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\")</ko>\n */\nexport interface PackingGridOptions extends GridOptions {\n  aspectRatio?: number;\n  sizeWeight?: number;\n  ratioWeight?: number;\n}\n\n/**\n * The PackingGrid is a layout that stacks cards with the same inlineSize as a stack of bricks. Adjust the inlineSize of all images to the same size, find the lowest contentSize column, and insert a necontentSize.\n *\n * @ko PackingGrid는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 카드를 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 카드 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @memberof Grid\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {Grid.PackingGrid.PackingGridOptions} options - The option object of the PackingGrid module <ko>PackingGrid 모듈의 옵션 객체</ko>\n */\n@GetterSetter\nexport class PackingGrid extends Grid<PackingGridOptions> {\n  public static propertyTypes = {\n    ...Grid.propertyTypes,\n    aspectRatio: PROPERTY_TYPE.RENDER_PROPERTY,\n    sizeWeight: PROPERTY_TYPE.RENDER_PROPERTY,\n    ratioWeight: PROPERTY_TYPE.RENDER_PROPERTY,\n  };\n  public static defaultOptions: Required<PackingGridOptions> = {\n    ...Grid.defaultOptions,\n    aspectRatio: 1,\n    sizeWeight: 1,\n    ratioWeight: 1,\n  };\n\n\n  public applyGrid(items: GridItem[], direction: \"start\" | \"end\", outline: number[]): GridOutlines {\n    const { aspectRatio, gap } = this.options;\n    const containerInlineSize = this.getContainerInlineSize();\n    const containerContentSize = containerInlineSize / aspectRatio;\n    const prevOutline = outline.length ? outline : [0];\n    const startPoint = direction === \"end\"\n      ? Math.max(...prevOutline)\n      : Math.min(...prevOutline) - containerContentSize - gap;\n    const endPoint = startPoint + containerContentSize + gap;\n    const container = new BoxModel({});\n\n    items.forEach((item) => {\n      const model = new BoxModel({\n        inlineSize: item.orgInlineSize,\n        contentSize: item.orgContentSize,\n        orgInlineSize: item.orgInlineSize,\n        orgContentSize: item.orgContentSize,\n      });\n\n      this._findBestFitArea(container, model);\n      container.push(model);\n      container.scaleTo(containerInlineSize + gap, containerContentSize + gap);\n    });\n    items.forEach((item, i) => {\n      const boxItem = container.items[i];\n      const inlineSize = boxItem.inlineSize - gap;\n      const contentSize = boxItem.contentSize - gap;\n      const contentPos = startPoint + boxItem.contentPos;\n      const inlinePos = boxItem.inlinePos;\n\n      item.setCSSGridRect({\n        inlinePos,\n        contentPos,\n        inlineSize,\n        contentSize,\n      });\n    });\n\n    return {\n      start: [startPoint],\n      end: [endPoint],\n    };\n  }\n  private _findBestFitArea(container: BoxModel, item: BoxModel) {\n    if (container.getRatio() === 0) { // 아이템 최초 삽입시 전체영역 지정\n      container.orgInlineSize = item.inlineSize;\n      container.orgContentSize = item.contentSize;\n      container.inlineSize = item.inlineSize;\n      container.contentSize = item.contentSize;\n      return;\n    }\n\n    let bestFitArea!: BoxModel;\n    let minCost = Infinity;\n    let isContentDirection = false;\n    const itemFitSize = {\n      inlineSize: 0,\n      contentSize: 0,\n    };\n    const containerFitSize = {\n      inlineSize: 0,\n      contentSize: 0,\n    };\n    const { sizeWeight, ratioWeight } = this.options;\n\n    container.items.forEach((child) => {\n      const containerSizeCost = getCost(child.getOrgSizeWeight(), child.getSize()) * sizeWeight;\n      const containerRatioCost = getCost(child.getOrgRatio(), child.getRatio()) * ratioWeight;\n      const inlineSize = child.inlineSize;\n      const contentSize = child.contentSize;\n      for (let i = 0; i < 2; ++i) {\n        let itemInlineSize;\n        let itemContentSize;\n        let containerInlineSize;\n        let containerContentSize;\n\n        if (i === 0) {\n          // add item to content pos (top, bottom)\n          itemInlineSize = inlineSize;\n          itemContentSize = contentSize * (item.contentSize / (child.orgContentSize + item.contentSize));\n          containerInlineSize = inlineSize;\n          containerContentSize = contentSize - itemContentSize;\n        } else {\n          // add item to inline pos (left, right)\n          itemContentSize = contentSize;\n          itemInlineSize = inlineSize * (item.inlineSize / (child.orgInlineSize + item.inlineSize));\n          containerContentSize = contentSize;\n          containerInlineSize = inlineSize - itemInlineSize;\n        }\n\n        const itemSize = itemInlineSize * itemContentSize;\n        const itemRatio = itemInlineSize / itemContentSize;\n        const containerSize = containerInlineSize * containerContentSize;\n        const containerRatio = containerContentSize / containerContentSize;\n\n        let cost = getCost(item.getSize(), itemSize) * sizeWeight;\n        cost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n        cost += getCost(child.getOrgSizeWeight(), containerSize) * sizeWeight - containerSizeCost;\n        cost += getCost(child.getOrgRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n        if (cost === Math.min(cost, minCost)) {\n          minCost = cost;\n          bestFitArea = child;\n          isContentDirection = (i === 0);\n          itemFitSize.inlineSize = itemInlineSize;\n          itemFitSize.contentSize = itemContentSize;\n          containerFitSize.inlineSize = containerInlineSize;\n          containerFitSize.contentSize = containerContentSize;\n        }\n      }\n    });\n\n    fitArea(item, bestFitArea, itemFitSize, containerFitSize, isContentDirection);\n  }\n}\n\nexport interface PackingGrid extends Properties<typeof PackingGrid> {\n}\n\n\n/**\n * Align of the position of the items. If you want to use `stretch`, be sure to set `column` or `columnSize` option. (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\")\n * @ko 아이템들의 위치의 정렬. `stretch`를 사용하고 싶다면 `column` 또는 `columnSize` 옵션을 설정해라.  (\"start\", \"center\", \"end\", \"justify\", \"stretch\") (default: \"justify\")\n * @name Grid.PackingGrid#align\n * @type {$ts:Grid.PackingGrid.PackingGridOptions[\"align\"]}\n * @example\n * import { PackingGrid } from \"@egjs/grid\";\n *\n * const grid = new PackingGrid(container, {\n *   align: \"start\",\n * });\n *\n * grid.align = \"justify\";\n */\n\n\n/**\n * The number of columns. If the number of columns is 0, it is automatically calculated according to the size of the container.\n * @ko 열의 개수. 열의 개수가 0이라면, 컨테이너의 사이즈에 의해 계산이 된다. (default: 0)\n * @name Grid.PackingGrid#column\n * @type {$ts:Grid.PackingGrid.PackingGridOptions[\"column\"]}\n * @example\n * import { PackingGrid } from \"@egjs/grid\";\n *\n * const grid = new PackingGrid(container, {\n *   column: 0,\n * });\n *\n * grid.column = 4;\n */\n\n\n/**\n * The size of the columns. If it is 0, it is calculated as the size of the first item in items. (default: 0)\n * @ko 열의 사이즈. 만약 열의 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. (default: 0)\n * @name Grid.PackingGrid#columnSize\n * @type {$ts:Grid.PackingGrid.PackingGridOptions[\"columnSize\"]}\n * @example\n * import { PackingGrid } from \"@egjs/grid\";\n *\n * const grid = new PackingGrid(container, {\n *   columnSize: 0,\n * });\n *\n * grid.columnSize = 200;\n */\n\n\n/**\n * The size ratio(inlineSize / contentSize) of the columns. 0 is not set. (default: 0)\n * @ko 열의 사이즈 비율(inlineSize / contentSize). 0은 미설정이다.\n * @name Grid.PackingGrid#columnSizeRatio\n * @type {$ts:Grid.PackingGrid.PackingGridOptions[\"columnSizeRatio\"]}\n * @example\n * import { PackingGrid } from \"@egjs/grid\";\n *\n * const grid = new PackingGrid(container, {\n *   columnSizeRatio: 0,\n * });\n *\n * grid.columnSizeRatio = 0.5;\n */\n","import Grid, * as modules from \"./index\";\n\n\nfor (const name in modules) {\n  (Grid as any)[name] = (modules as any)[name];\n}\nexport default Grid;\n"],"names":["PROPERTY_TYPE","MOUNT_STATE","UPDATE_STATE","DEFAULT_GRID_OPTIONS","horizontal","useTransform","percentage","isEqualSize","isConstantSize","gap","attributePrefix","resizeDebounce","maxResizeDebounce","autoResize","defaultDirection","externalContainerManager","externalItemRenderer","renderOnPropertyChange","GRID_PROPERTY_TYPES","RENDER_PROPERTY","PROPERTY","GRID_METHODS","RECT_NAMES","inlinePos","contentPos","inlineSize","contentSize","vertical","container","options","_init","this","setRect","width","offsetWidth","height","offsetHeight","rect","status","setContentSize","getContentSize","size","sizeName","style","preserveUI","cssText","orgCSSText","window","getComputedStyle","position","isObject","val","GetterSetter","component","name","prototype","propertyTypes","shouldRender","Object","defineProperty","enumerable","configurable","get","set","value","scheduleRender","withMethods","methods","memberName","forEach","_i","args","result","_a","range","length","arr","i","push","getRangeCost","Math","max","withGridMethods","initialRect","items","item","_this","_renderItem","containerRect","_updateItem","sizePercentage","posPercentage","indexOf","posPercetage","sizePercetage","orgRect","element","hasOrgRect","left","offsetLeft","top","offsetTop","mountState","MOUNTED","updateState","NEED_UPDATE","UPDATED","attributes","dataAttributes","attribute","replace","all","letter","toUpperCase","getDataAttributes","cssTexts","posName","obj","cssRect","_b","getInlineSize","keys","filter","key","map","join","itemStatus","data","UNCHECKED","gridRect","names","containerElement","_super","start","end","clearTimeout","_resizeTimer","_maxResizeDebounceTimer","renderItems","useResize","setTimeout","_onResize","constructor","defaultOptions","document","querySelector","containerManager","ContainerManager","itemRenderer","ItemRenderer","__extends","slice","call","children","outlines","elements","getChildren","diff","added","maintained","changed","removed","nextItems","beforeIndex","afterIndex","index","GridItem","setItems","checkReady","_clearRenderTimer","getItems","syncElements","_resizeContainer","updateItems","getStatus","prevInlineSize","setStatus","_renderComplete","mounted","updated","isResize","destroy","removeEventListener","_scheduleResize","_im","moreUpdated","ImReady","prefix","on","e","hasLoading","WAIT_LOADING","_renderItems","isPreReadyOver","trigger","target","update","check","_renderTimer","startOutline","endOutline","outlineOffset","min","point","cssContentPos","prevOutlines","direction","prevOutline","outline","nextOutlines","applyGrid","setOutlines","_fit","_refreshContainerContentSize","endPoint","startPoint","resize","setContainerRect","getRect","addEventListener","Grid","Component","_calculateColumnSize","_calculateColumn","point_1","column","_column","columnSize","_columnSize","align","columnSizeRatio","outlineLength","itemsLength","alignPoses","_getAlignPoses","isEndDirection","pointCalculateName","indexCalculateName","columnDist","isStretch","columnIndex","columnAttribute","parseInt","maxColumn","itemColumn","ceil","endColumnIndex","columnOutline","columnPoint","nextEndColumnIndex","cssInlineSize","cssContentSize","endContentPos","cssInlinePos","indexOffset","columnSizeOption","floor","getContainerInlineSize","items_1","columnOption","containerSize","indexes","offset","dist","countDist","totalColumnSize","MasonryGrid","find_path","graph","s","d","predecessors","nodes","u","reverse","extract_shortest_path_from_predecessor_list","costs","closest","cost_of_s_to_u","adjacent_nodes","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","open","BinaryHeap","x","cost","v","pop","msg","Error","single_source_shortest_paths","scoreFunction","content","bubbleUp","sinkDown","_n","n","parentN","parent","elemScore","child1Score","child2N","child1N","swap","child1","child2","rowRange","path","_getRowPath","_getPath","_setStyle","columnRangeOption","rowRangeOption","columnRange","pathLink","_getRowLink","currentNode","node","currentLink","minColumn","minRow","maxRow","lastNode","pathLength","lastCost","abs","_getCost","isOver","_searchRowLink","nextLink","links","nextNode","nextCost","sort","a","b","aIsOver","reduce","sum","orgInlineSize","orgContentSize","j","_getSize","sizeRange","minSize","maxSize","isFinite","pow","nodeKey","results","path1","path2","pathItems","pathItemsLength","prevItem","setCSSGridRect","JustifiedGrid","Infinity","getMaxPoint","maxPoint","getOutlineDist","useFrameFill","minPoint","minEndPoint","maxStartPoint","frameDist","outlineIndex","startPos","endPos","fillOutlines","frame","_getFrame","frameInlineSize","frameContentSize","frameRects","getRectSize","rectInlineSize","rectContentSize","frameOutline","rectsLength","startIndex","rectIndex","_c","frameRectContentPos","frameRectInlinePos","frameRectContentSize","frameRectInlineSize","isDirectionEnd","gridOutline","outlineDist","rectSizeOption","rectSizeValue","rects","passMap","y1","x1","type","_findRect","x2","y2","y","FrameGrid","rectSize","boxStatus","scaleX","scaleY","getCost","originLength","aspectRatio","containerInlineSize","containerContentSize","BoxModel","model","_findBestFitArea","scaleTo","boxItem","getRatio","bestFitArea","itemFitSize","containerFitSize","minCost","isContentDirection","sizeWeight","ratioWeight","child","containerSizeCost","getOrgSizeWeight","getSize","containerRatioCost","getOrgRatio","itemInlineSize","itemContentSize","itemSize","itemRatio","containerRatio","PackingGrid","modules"],"mappings":"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"}